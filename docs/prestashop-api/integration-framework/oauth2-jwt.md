# OAuth2/JWT Authentication - PrestaShop Integration Framework\n\n## Descripci√≥n General\n\nEl **PrestaShop Integration Framework** utiliza autenticaci√≥n OAuth2 con tokens JWT para proporcionar acceso seguro a APIs modernas y versionadas. Este sistema est√° dise√±ado para integraciones empresariales y aplicaciones de terceros.\n\n## Caracter√≠sticas Principales\n\n### ‚ú® Funcionalidades\n- üîê **Autenticaci√≥n OAuth2**: Est√°ndar de la industria\n- üé´ **Tokens JWT**: Seguros y aut√≥nomos\n- üìö **APIs Versionadas**: Compatibilidad hacia atr√°s garantizada\n- üìñ **OpenAPI 3.0**: Documentaci√≥n completa\n- üîÑ **Actualizaciones Regulares**: Mantenimiento activo\n\n### üéØ Casos de Uso\n- Integraciones empresariales\n- Aplicaciones de terceros certificadas\n- Automatizaci√≥n de workflows\n- Sincronizaci√≥n con plataformas externas\n- Reportes y an√°lisis avanzados\n\n## Proceso de Autenticaci√≥n OAuth2\n\n### 1. Obtenci√≥n de Credenciales\n\n#### Registro con PrestaShop\n1. **Contactar PrestaShop Solution Engineers**\n   - Solicitar credenciales de cliente\n   - Proporcionar detalles del proyecto\n   - Especificar alcance requerido\n\n2. **Credenciales Proporcionadas**\n   ```json\n   {\n     \"client_id\": \"your-client-id\",\n     \"client_secret\": \"your-client-secret\",\n     \"scope\": \"read write\",\n     \"authorization_server\": \"https://oauth.prestashop.com/\"\n   }\n   ```\n\n### 2. Flujo de Autenticaci√≥n\n\n#### Authorization Code Flow (Recomendado)\n\n```mermaid\nsequenceDiagram\n    participant App as Aplicaci√≥n\n    participant User as Usuario\n    participant Auth as OAuth Server\n    participant API as PrestaShop API\n    \n    App->>User: Redirigir a autorizaci√≥n\n    User->>Auth: Autenticar y autorizar\n    Auth->>App: C√≥digo de autorizaci√≥n\n    App->>Auth: Intercambiar c√≥digo por token\n    Auth->>App: Access Token JWT\n    App->>API: Request con Bearer Token\n    API->>App: Respuesta de API\n```\n\n#### Paso 1: Autorizaci√≥n\n```http\nGET https://oauth.prestashop.com/oauth/authorize?\n    response_type=code&\n    client_id=YOUR_CLIENT_ID&\n    redirect_uri=YOUR_REDIRECT_URI&\n    scope=read+write&\n    state=RANDOM_STATE_STRING\n```\n\n#### Paso 2: Intercambio de C√≥digo\n```http\nPOST https://oauth.prestashop.com/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&\ncode=AUTHORIZATION_CODE&\nclient_id=YOUR_CLIENT_ID&\nclient_secret=YOUR_CLIENT_SECRET&\nredirect_uri=YOUR_REDIRECT_URI\n```\n\n#### Respuesta del Token\n```json\n{\n  \"access_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600,\n  \"refresh_token\": \"def50200...\",\n  \"scope\": \"read write\"\n}\n```\n\n### 3. Client Credentials Flow (Aplicaciones Server-to-Server)\n\n```http\nPOST https://oauth.prestashop.com/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials&\nclient_id=YOUR_CLIENT_ID&\nclient_secret=YOUR_CLIENT_SECRET&\nscope=read+write\n```\n\n## Uso de Tokens JWT\n\n### Estructura del Token JWT\n\n```javascript\n// Header\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"key-id\"\n}\n\n// Payload\n{\n  \"iss\": \"https://oauth.prestashop.com\",\n  \"sub\": \"client-id\",\n  \"aud\": \"prestashop-api\",\n  \"exp\": 1640995200,\n  \"iat\": 1640991600,\n  \"scope\": \"read write\",\n  \"shop_id\": \"12345\"\n}\n```\n\n### Autenticaci√≥n en Requests\n\n```http\nGET https://api.prestashop.com/v1/products\nAuthorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\nAccept: application/json\n```\n\n## Implementaci√≥n por Lenguaje\n\n### üêò PHP\n\n#### Cliente OAuth2\n```php\n<?php\nrequire_once 'vendor/autoload.php';\n\nuse League\\OAuth2\\Client\\Provider\\GenericProvider;\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\n\nclass PrestaShopOAuth2Client\n{\n    private $provider;\n    private $clientId;\n    private $clientSecret;\n    \n    public function __construct($clientId, $clientSecret, $redirectUri)\n    {\n        $this->clientId = $clientId;\n        $this->clientSecret = $clientSecret;\n        \n        $this->provider = new GenericProvider([\n            'clientId' => $clientId,\n            'clientSecret' => $clientSecret,\n            'redirectUri' => $redirectUri,\n            'urlAuthorize' => 'https://oauth.prestashop.com/oauth/authorize',\n            'urlAccessToken' => 'https://oauth.prestashop.com/oauth/token',\n            'urlResourceOwnerDetails' => 'https://oauth.prestashop.com/oauth/user'\n        ]);\n    }\n    \n    public function getAuthorizationUrl($state = null)\n    {\n        $options = [\n            'scope' => 'read write',\n            'state' => $state ?: bin2hex(random_bytes(16))\n        ];\n        \n        return $this->provider->getAuthorizationUrl($options);\n    }\n    \n    public function getAccessToken($code)\n    {\n        try {\n            $accessToken = $this->provider->getAccessToken('authorization_code', [\n                'code' => $code\n            ]);\n            \n            return [\n                'access_token' => $accessToken->getToken(),\n                'refresh_token' => $accessToken->getRefreshToken(),\n                'expires' => $accessToken->getExpires()\n            ];\n        } catch (Exception $e) {\n            throw new Exception('Error obteniendo access token: ' . $e->getMessage());\n        }\n    }\n    \n    public function getClientCredentialsToken()\n    {\n        try {\n            $accessToken = $this->provider->getAccessToken('client_credentials', [\n                'scope' => 'read write'\n            ]);\n            \n            return $accessToken->getToken();\n        } catch (Exception $e) {\n            throw new Exception('Error obteniendo client credentials token: ' . $e->getMessage());\n        }\n    }\n    \n    public function refreshToken($refreshToken)\n    {\n        try {\n            $accessToken = $this->provider->getAccessToken('refresh_token', [\n                'refresh_token' => $refreshToken\n            ]);\n            \n            return [\n                'access_token' => $accessToken->getToken(),\n                'refresh_token' => $accessToken->getRefreshToken(),\n                'expires' => $accessToken->getExpires()\n            ];\n        } catch (Exception $e) {\n            throw new Exception('Error renovando token: ' . $e->getMessage());\n        }\n    }\n    \n    public function validateToken($token)\n    {\n        try {\n            // Obtener clave p√∫blica de PrestaShop\n            $publicKey = $this->getPublicKey();\n            \n            $decoded = JWT::decode($token, new Key($publicKey, 'RS256'));\n            \n            return [\n                'valid' => true,\n                'payload' => $decoded,\n                'expires_at' => $decoded->exp\n            ];\n        } catch (Exception $e) {\n            return [\n                'valid' => false,\n                'error' => $e->getMessage()\n            ];\n        }\n    }\n    \n    private function getPublicKey()\n    {\n        // Implementar cache para la clave p√∫blica\n        $cacheKey = 'prestashop_oauth_public_key';\n        $cached = apcu_get($cacheKey);\n        \n        if ($cached === false) {\n            $response = file_get_contents('https://oauth.prestashop.com/.well-known/jwks.json');\n            $jwks = json_decode($response, true);\n            \n            // Extraer clave p√∫blica del JWKS\n            $publicKey = $this->jwksToPublicKey($jwks);\n            \n            apcu_set($cacheKey, $publicKey, 3600); // Cache por 1 hora\n            return $publicKey;\n        }\n        \n        return $cached;\n    }\n}\n\n// Uso\n$oauth = new PrestaShopOAuth2Client(\n    $_ENV['PRESTASHOP_CLIENT_ID'],\n    $_ENV['PRESTASHOP_CLIENT_SECRET'],\n    'https://miapp.com/callback'\n);\n\n// Para aplicaciones web\nif (!isset($_GET['code'])) {\n    $authUrl = $oauth->getAuthorizationUrl();\n    header('Location: ' . $authUrl);\n    exit;\n} else {\n    $token = $oauth->getAccessToken($_GET['code']);\n    // Guardar token en sesi√≥n o base de datos\n    $_SESSION['prestashop_token'] = $token;\n}\n\n// Para aplicaciones server-to-server\n$token = $oauth->getClientCredentialsToken();\n?>\n```\n\n### üü® JavaScript (Node.js)\n\n#### Cliente OAuth2 con Node.js\n```javascript\nconst axios = require('axios');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\n\nclass PrestaShopOAuth2Client {\n    constructor(clientId, clientSecret, redirectUri) {\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n        this.redirectUri = redirectUri;\n        this.authServerUrl = 'https://oauth.prestashop.com';\n        \n        this.jwksClient = jwksClient({\n            jwksUri: `${this.authServerUrl}/.well-known/jwks.json`,\n            cache: true,\n            cacheMaxEntries: 5,\n            cacheMaxAge: 600000 // 10 minutos\n        });\n    }\n    \n    getAuthorizationUrl(state) {\n        const params = new URLSearchParams({\n            response_type: 'code',\n            client_id: this.clientId,\n            redirect_uri: this.redirectUri,\n            scope: 'read write',\n            state: state || this.generateState()\n        });\n        \n        return `${this.authServerUrl}/oauth/authorize?${params}`;\n    }\n    \n    async getAccessToken(code) {\n        try {\n            const response = await axios.post(`${this.authServerUrl}/oauth/token`, {\n                grant_type: 'authorization_code',\n                code: code,\n                client_id: this.clientId,\n                client_secret: this.clientSecret,\n                redirect_uri: this.redirectUri\n            }, {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            });\n            \n            return response.data;\n        } catch (error) {\n            throw new Error(`Error obteniendo access token: ${error.response?.data?.error || error.message}`);\n        }\n    }\n    \n    async getClientCredentialsToken() {\n        try {\n            const response = await axios.post(`${this.authServerUrl}/oauth/token`, {\n                grant_type: 'client_credentials',\n                client_id: this.clientId,\n                client_secret: this.clientSecret,\n                scope: 'read write'\n            }, {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            });\n            \n            return response.data.access_token;\n        } catch (error) {\n            throw new Error(`Error obteniendo client credentials token: ${error.response?.data?.error || error.message}`);\n        }\n    }\n    \n    async refreshToken(refreshToken) {\n        try {\n            const response = await axios.post(`${this.authServerUrl}/oauth/token`, {\n                grant_type: 'refresh_token',\n                refresh_token: refreshToken,\n                client_id: this.clientId,\n                client_secret: this.clientSecret\n            }, {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            });\n            \n            return response.data;\n        } catch (error) {\n            throw new Error(`Error renovando token: ${error.response?.data?.error || error.message}`);\n        }\n    }\n    \n    async validateToken(token) {\n        return new Promise((resolve, reject) => {\n            const decoded = jwt.decode(token, { complete: true });\n            \n            if (!decoded) {\n                return resolve({ valid: false, error: 'Token malformado' });\n            }\n            \n            this.jwksClient.getSigningKey(decoded.header.kid, (err, key) => {\n                if (err) {\n                    return resolve({ valid: false, error: err.message });\n                }\n                \n                const signingKey = key.getPublicKey();\n                \n                jwt.verify(token, signingKey, { algorithms: ['RS256'] }, (err, payload) => {\n                    if (err) {\n                        return resolve({ valid: false, error: err.message });\n                    }\n                    \n                    resolve({\n                        valid: true,\n                        payload: payload,\n                        expires_at: payload.exp\n                    });\n                });\n            });\n        });\n    }\n    \n    generateState() {\n        return require('crypto').randomBytes(16).toString('hex');\n    }\n}\n\n// Uso\nconst oauth = new PrestaShopOAuth2Client(\n    process.env.PRESTASHOP_CLIENT_ID,\n    process.env.PRESTASHOP_CLIENT_SECRET,\n    'https://miapp.com/callback'\n);\n\n// Express.js example\nconst express = require('express');\nconst app = express();\n\napp.get('/auth', (req, res) => {\n    const state = oauth.generateState();\n    req.session.oauth_state = state;\n    \n    const authUrl = oauth.getAuthorizationUrl(state);\n    res.redirect(authUrl);\n});\n\napp.get('/callback', async (req, res) => {\n    const { code, state } = req.query;\n    \n    if (state !== req.session.oauth_state) {\n        return res.status(400).send('Estado inv√°lido');\n    }\n    \n    try {\n        const tokenData = await oauth.getAccessToken(code);\n        req.session.prestashop_token = tokenData;\n        \n        res.json({ success: true, token: tokenData });\n    } catch (error) {\n        res.status(400).json({ error: error.message });\n    }\n});\n\n// Para aplicaciones server-to-server\nasync function getServerToken() {\n    try {\n        const token = await oauth.getClientCredentialsToken();\n        console.log('Token obtenido:', token);\n        return token;\n    } catch (error) {\n        console.error('Error:', error.message);\n    }\n}\n```\n\n### üêç Python\n\n#### Cliente OAuth2 con Python\n```python\nimport requests\nimport jwt\nimport time\nimport secrets\nfrom urllib.parse import urlencode, parse_qs\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\n\nclass PrestaShopOAuth2Client:\n    def __init__(self, client_id, client_secret, redirect_uri):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.redirect_uri = redirect_uri\n        self.auth_server_url = 'https://oauth.prestashop.com'\n        self._public_keys_cache = {}\n        \n    def get_authorization_url(self, state=None):\n        if state is None:\n            state = secrets.token_urlsafe(16)\n            \n        params = {\n            'response_type': 'code',\n            'client_id': self.client_id,\n            'redirect_uri': self.redirect_uri,\n            'scope': 'read write',\n            'state': state\n        }\n        \n        return f\"{self.auth_server_url}/oauth/authorize?{urlencode(params)}\"\n    \n    def get_access_token(self, code):\n        data = {\n            'grant_type': 'authorization_code',\n            'code': code,\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n            'redirect_uri': self.redirect_uri\n        }\n        \n        response = requests.post(\n            f\"{self.auth_server_url}/oauth/token\",\n            data=data,\n            headers={'Content-Type': 'application/x-www-form-urlencoded'}\n        )\n        \n        if response.status_code != 200:\n            raise Exception(f\"Error obteniendo access token: {response.text}\")\n            \n        return response.json()\n    \n    def get_client_credentials_token(self):\n        data = {\n            'grant_type': 'client_credentials',\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n            'scope': 'read write'\n        }\n        \n        response = requests.post(\n            f\"{self.auth_server_url}/oauth/token\",\n            data=data,\n            headers={'Content-Type': 'application/x-www-form-urlencoded'}\n        )\n        \n        if response.status_code != 200:\n            raise Exception(f\"Error obteniendo client credentials token: {response.text}\")\n            \n        return response.json()['access_token']\n    \n    def refresh_token(self, refresh_token):\n        data = {\n            'grant_type': 'refresh_token',\n            'refresh_token': refresh_token,\n            'client_id': self.client_id,\n            'client_secret': self.client_secret\n        }\n        \n        response = requests.post(\n            f\"{self.auth_server_url}/oauth/token\",\n            data=data,\n            headers={'Content-Type': 'application/x-www-form-urlencoded'}\n        )\n        \n        if response.status_code != 200:\n            raise Exception(f\"Error renovando token: {response.text}\")\n            \n        return response.json()\n    \n    def validate_token(self, token):\n        try:\n            # Decodificar header para obtener kid\n            unverified_header = jwt.get_unverified_header(token)\n            kid = unverified_header.get('kid')\n            \n            # Obtener clave p√∫blica\n            public_key = self._get_public_key(kid)\n            \n            # Verificar token\n            payload = jwt.decode(\n                token, \n                public_key, \n                algorithms=['RS256'],\n                audience='prestashop-api',\n                issuer=self.auth_server_url\n            )\n            \n            return {\n                'valid': True,\n                'payload': payload,\n                'expires_at': payload['exp']\n            }\n            \n        except jwt.ExpiredSignatureError:\n            return {'valid': False, 'error': 'Token expirado'}\n        except jwt.InvalidTokenError as e:\n            return {'valid': False, 'error': f'Token inv√°lido: {str(e)}'}\n        except Exception as e:\n            return {'valid': False, 'error': f'Error validando token: {str(e)}'}\n    \n    def _get_public_key(self, kid):\n        # Cache de claves p√∫blicas\n        cache_key = f\"public_key_{kid}\"\n        \n        if cache_key in self._public_keys_cache:\n            cached_key, cached_time = self._public_keys_cache[cache_key]\n            if time.time() - cached_time < 3600:  # Cache por 1 hora\n                return cached_key\n        \n        # Obtener JWKS\n        response = requests.get(f\"{self.auth_server_url}/.well-known/jwks.json\")\n        jwks = response.json()\n        \n        # Buscar clave espec√≠fica\n        for key_data in jwks['keys']:\n            if key_data['kid'] == kid:\n                # Convertir JWK a clave PEM\n                public_key = self._jwk_to_pem(key_data)\n                \n                # Guardar en cache\n                self._public_keys_cache[cache_key] = (public_key, time.time())\n                \n                return public_key\n        \n        raise Exception(f\"Clave p√∫blica no encontrada para kid: {kid}\")\n    \n    def _jwk_to_pem(self, jwk_data):\n        # Implementar conversi√≥n de JWK a PEM\n        # Esta es una implementaci√≥n simplificada\n        from cryptography.hazmat.primitives.asymmetric import rsa\n        from cryptography.hazmat.primitives import serialization\n        import base64\n        \n        n = int.from_bytes(\n            base64.urlsafe_b64decode(jwk_data['n'] + '=='), \n            byteorder='big'\n        )\n        e = int.from_bytes(\n            base64.urlsafe_b64decode(jwk_data['e'] + '=='), \n            byteorder='big'\n        )\n        \n        public_key = rsa.RSAPublicNumbers(e, n).public_key()\n        \n        return public_key.public_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PublicFormat.SubjectPublicKeyInfo\n        )\n\n# Uso\nimport os\nfrom flask import Flask, request, session, redirect, jsonify\n\napp = Flask(__name__)\napp.secret_key = 'tu-secret-key'\n\noauth = PrestaShopOAuth2Client(\n    os.getenv('PRESTASHOP_CLIENT_ID'),\n    os.getenv('PRESTASHOP_CLIENT_SECRET'),\n    'https://miapp.com/callback'\n)\n\n@app.route('/auth')\ndef auth():\n    state = secrets.token_urlsafe(16)\n    session['oauth_state'] = state\n    \n    auth_url = oauth.get_authorization_url(state)\n    return redirect(auth_url)\n\n@app.route('/callback')\ndef callback():\n    code = request.args.get('code')\n    state = request.args.get('state')\n    \n    if state != session.get('oauth_state'):\n        return jsonify({'error': 'Estado inv√°lido'}), 400\n    \n    try:\n        token_data = oauth.get_access_token(code)\n        session['prestashop_token'] = token_data\n        \n        return jsonify({'success': True, 'token': token_data})\n    except Exception as e:\n        return jsonify({'error': str(e)}), 400\n\n# Para aplicaciones server-to-server\ndef get_server_token():\n    try:\n        token = oauth.get_client_credentials_token()\n        print(f\"Token obtenido: {token}\")\n        return token\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return None\n\nif __name__ == '__main__':\n    # Ejemplo server-to-server\n    token = get_server_token()\n    if token:\n        # Usar token para hacer requests a la API\n        headers = {'Authorization': f'Bearer {token}'}\n        response = requests.get('https://api.prestashop.com/v1/products', headers=headers)\n        print(response.json())\n```\n\n## Gesti√≥n de Tokens\n\n### Almacenamiento Seguro\n\n```php\n// PHP - Almacenamiento en base de datos\nclass TokenManager\n{\n    private $pdo;\n    \n    public function __construct($pdo)\n    {\n        $this->pdo = $pdo;\n    }\n    \n    public function storeToken($userId, $tokenData)\n    {\n        $stmt = $this->pdo->prepare(\"\n            INSERT INTO oauth_tokens (user_id, access_token, refresh_token, expires_at) \n            VALUES (?, ?, ?, ?)\n            ON DUPLICATE KEY UPDATE \n            access_token = VALUES(access_token),\n            refresh_token = VALUES(refresh_token),\n            expires_at = VALUES(expires_at)\n        \");\n        \n        $expiresAt = date('Y-m-d H:i:s', time() + $tokenData['expires_in']);\n        \n        return $stmt->execute([\n            $userId,\n            $tokenData['access_token'],\n            $tokenData['refresh_token'],\n            $expiresAt\n        ]);\n    }\n    \n    public function getValidToken($userId)\n    {\n        $stmt = $this->pdo->prepare(\"\n            SELECT * FROM oauth_tokens \n            WHERE user_id = ? AND expires_at > NOW()\n        \");\n        \n        $stmt->execute([$userId]);\n        return $stmt->fetch(PDO::FETCH_ASSOC);\n    }\n    \n    public function refreshTokenIfNeeded($userId)\n    {\n        $tokenData = $this->getValidToken($userId);\n        \n        if (!$tokenData) {\n            // Token expirado, intentar renovar\n            $stmt = $this->pdo->prepare(\"\n                SELECT refresh_token FROM oauth_tokens WHERE user_id = ?\n            \");\n            $stmt->execute([$userId]);\n            $refreshToken = $stmt->fetchColumn();\n            \n            if ($refreshToken) {\n                $oauth = new PrestaShopOAuth2Client(/* ... */);\n                $newTokenData = $oauth->refreshToken($refreshToken);\n                $this->storeToken($userId, $newTokenData);\n                \n                return $newTokenData['access_token'];\n            }\n        }\n        \n        return $tokenData['access_token'];\n    }\n}\n```\n\n### Auto-renovaci√≥n de Tokens\n\n```javascript\n// JavaScript - Middleware para auto-renovaci√≥n\nclass TokenManager {\n    constructor(oauth, storage) {\n        this.oauth = oauth;\n        this.storage = storage;\n        this.refreshPromise = null;\n    }\n    \n    async getValidToken(userId) {\n        const tokenData = await this.storage.getToken(userId);\n        \n        if (!tokenData) {\n            throw new Error('No token found');\n        }\n        \n        // Verificar si el token expira en los pr√≥ximos 5 minutos\n        const expiresIn = tokenData.expires_at - Math.floor(Date.now() / 1000);\n        \n        if (expiresIn < 300) { // 5 minutos\n            return this.refreshToken(userId);\n        }\n        \n        return tokenData.access_token;\n    }\n    \n    async refreshToken(userId) {\n        // Evitar m√∫ltiples refreshes simult√°neos\n        if (this.refreshPromise) {\n            return this.refreshPromise;\n        }\n        \n        this.refreshPromise = this._doRefresh(userId);\n        \n        try {\n            const result = await this.refreshPromise;\n            return result;\n        } finally {\n            this.refreshPromise = null;\n        }\n    }\n    \n    async _doRefresh(userId) {\n        const tokenData = await this.storage.getToken(userId);\n        \n        if (!tokenData.refresh_token) {\n            throw new Error('No refresh token available');\n        }\n        \n        const newTokenData = await this.oauth.refreshToken(tokenData.refresh_token);\n        \n        await this.storage.storeToken(userId, newTokenData);\n        \n        return newTokenData.access_token;\n    }\n}\n\n// Middleware para Express\nfunction requireValidToken(req, res, next) {\n    const tokenManager = req.app.locals.tokenManager;\n    const userId = req.user.id;\n    \n    tokenManager.getValidToken(userId)\n        .then(token => {\n            req.prestashopToken = token;\n            next();\n        })\n        .catch(error => {\n            res.status(401).json({ error: 'Token inv√°lido o expirado' });\n        });\n}\n```\n\n## Mejores Pr√°cticas\n\n### 1. Seguridad\n- ‚úÖ Usar HTTPS siempre\n- ‚úÖ Validar state parameter\n- ‚úÖ Almacenar tokens de forma segura\n- ‚úÖ Implementar rate limiting\n- ‚úÖ Rotar client secrets regularmente\n\n### 2. Gesti√≥n de Errores\n```javascript\nclass APIError extends Error {\n    constructor(message, status, code) {\n        super(message);\n        this.status = status;\n        this.code = code;\n    }\n}\n\nfunction handleOAuthError(error) {\n    if (error.response) {\n        const { status, data } = error.response;\n        \n        switch (data.error) {\n            case 'invalid_grant':\n                throw new APIError('C√≥digo de autorizaci√≥n inv√°lido', 400, 'INVALID_GRANT');\n            case 'invalid_client':\n                throw new APIError('Credenciales de cliente inv√°lidas', 401, 'INVALID_CLIENT');\n            case 'access_denied':\n                throw new APIError('Acceso denegado por el usuario', 403, 'ACCESS_DENIED');\n            default:\n                throw new APIError(data.error_description || 'Error OAuth', status, data.error);\n        }\n    }\n    \n    throw error;\n}\n```\n\n### 3. Logging y Monitoreo\n```php\nclass OAuthLogger\n{\n    public static function logTokenRequest($clientId, $grantType, $success, $error = null)\n    {\n        $logData = [\n            'timestamp' => date('c'),\n            'client_id' => $clientId,\n            'grant_type' => $grantType,\n            'success' => $success,\n            'error' => $error,\n            'ip' => $_SERVER['REMOTE_ADDR'] ?? 'unknown'\n        ];\n        \n        error_log('OAuth Token Request: ' . json_encode($logData));\n    }\n    \n    public static function logTokenUsage($token, $endpoint, $success)\n    {\n        // Log uso de tokens para auditor√≠a\n        $payload = jwt_decode($token);\n        \n        $logData = [\n            'timestamp' => date('c'),\n            'client_id' => $payload->sub ?? 'unknown',\n            'endpoint' => $endpoint,\n            'success' => $success,\n            'token_expires' => date('c', $payload->exp ?? 0)\n        ];\n        \n        error_log('OAuth Token Usage: ' . json_encode($logData));\n    }\n}\n```\n\n---\n\n**Importante**: El Integration Framework requiere registro previo con PrestaShop. Las credenciales deben solicitarse a trav√©s de canales oficiales y el proceso puede incluir revisi√≥n de la aplicaci√≥n.