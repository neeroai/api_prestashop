# Otros Módulos de API para PrestaShop\n\n## Módulos Alternativos de Terceros\n\n### 🔌 PrestaShop REST API Modules\n\n#### 1. **PrestaShop GraphQL API**\n- **Descripción**: API GraphQL moderna para PrestaShop\n- **Características**:\n  - Query flexible de datos\n  - Reducción de over-fetching\n  - Schema introspection\n  - Compatible con herramientas GraphQL\n- **Uso**: Aplicaciones que requieren queries complejas\n- **Estado**: Desarrollo comunitario\n\n#### 2. **WebKul PrestaShop API Extensions**\n- **Descripción**: Extensiones API comerciales\n- **Características**:\n  - APIs especializadas por funcionalidad\n  - Marketplace API\n  - Mobile App APIs\n  - Multi-vendor support\n- **Licencia**: Comercial\n- **Soporte**: Oficial de WebKul\n\n#### 3. **Custom REST Modules**\n- **Descripción**: Módulos personalizados desarrollados por la comunidad\n- **Características**:\n  - Endpoints específicos por necesidad\n  - Integración con sistemas ERP\n  - APIs de sincronización\n- **Disponibilidad**: GitHub, PrestaShop Addons\n\n## Comparación de Alternativas\n\n### Tabla Comparativa\n\n| Característica | API Oficial | Binshops REST | GraphQL | WebKul APIs |\n|----------------|-------------|---------------|---------|-------------|\n| **Costo** | Gratuito | Freemium | Gratuito | Comercial |\n| **Mantenimiento** | Oficial | Terceros | Comunidad | Comercial |\n| **Flexibilidad** | Media | Alta | Muy Alta | Media |\n| **Documentación** | Buena | Excelente | Variable | Buena |\n| **Soporte Frontend** | Básico | Excelente | Muy Bueno | Bueno |\n| **Curva Aprendizaje** | Media | Baja | Alta | Media |\n\n## Módulos Especializados\n\n### 📱 Mobile App APIs\n\n#### PrestaShop Mobile App Creator\n- **Función**: APIs específicas para apps móviles\n- **Características**:\n  - Push notifications\n  - Offline capabilities\n  - Native mobile features\n  - App store optimization\n\n#### Flutter/React Native Modules\n- **Función**: SDKs para frameworks móviles\n- **Características**:\n  - Widgets pre-construidos\n  - State management\n  - Authentication helpers\n  - Payment integrations\n\n### 🏪 Marketplace APIs\n\n#### Multi-Vendor API Extensions\n- **Función**: APIs para mercados multi-vendedor\n- **Características**:\n  - Vendor management\n  - Commission tracking\n  - Separate vendor dashboards\n  - Vendor-specific products\n\n### 🔄 Synchronization Modules\n\n#### ERP Integration APIs\n- **Función**: Sincronización con sistemas ERP\n- **Características**:\n  - Real-time sync\n  - Batch processing\n  - Error handling\n  - Mapping configurations\n\n#### Inventory Management APIs\n- **Función**: Gestión avanzada de inventario\n- **Características**:\n  - Multi-warehouse support\n  - Stock reservations\n  - Automatic reordering\n  - Supplier integration\n\n## Desarrollo de Módulos Personalizados\n\n### Estructura Base de Módulo API\n\n```php\n<?php\n// modules/custom_api/custom_api.php\n\nclass Custom_Api extends Module\n{\n    public function __construct()\n    {\n        $this->name = 'custom_api';\n        $this->tab = 'administration';\n        $this->version = '1.0.0';\n        $this->author = 'Tu Nombre';\n        $this->need_instance = 0;\n        \n        parent::__construct();\n        \n        $this->displayName = $this->l('Custom API Module');\n        $this->description = $this->l('Módulo API personalizado');\n    }\n    \n    public function install()\n    {\n        return parent::install() && \n               $this->registerHook('moduleRoutes');\n    }\n    \n    public function hookModuleRoutes()\n    {\n        return [\n            'custom_api_products' => [\n                'rule' => 'api/custom/products',\n                'keywords' => [],\n                'controller' => 'products',\n                'params' => [\n                    'fc' => 'module',\n                    'module' => 'custom_api'\n                ]\n            ]\n        ];\n    }\n}\n```\n\n### Controller Personalizado\n\n```php\n<?php\n// modules/custom_api/controllers/front/products.php\n\nclass Custom_ApiProductsModuleFrontController extends ModuleFrontController\n{\n    public function initContent()\n    {\n        parent::initContent();\n        \n        // Disable layout for API response\n        $this->display_header = false;\n        $this->display_footer = false;\n        \n        $this->processApiRequest();\n    }\n    \n    private function processApiRequest()\n    {\n        header('Content-Type: application/json');\n        \n        $method = $_SERVER['REQUEST_METHOD'];\n        \n        switch ($method) {\n            case 'GET':\n                $this->handleGetRequest();\n                break;\n            case 'POST':\n                $this->handlePostRequest();\n                break;\n            default:\n                http_response_code(405);\n                echo json_encode(['error' => 'Method not allowed']);\n        }\n        \n        exit;\n    }\n    \n    private function handleGetRequest()\n    {\n        $products = Product::getProducts(\n            Context::getContext()->language->id,\n            0,\n            100,\n            'id_product',\n            'DESC',\n            false,\n            true\n        );\n        \n        $response = [\n            'success' => true,\n            'data' => $products,\n            'count' => count($products)\n        ];\n        \n        echo json_encode($response);\n    }\n}\n```\n\n## Integración con Sistemas Externos\n\n### Webhooks Module\n\n```php\n<?php\n// Módulo para webhooks salientes\nclass WebhooksModule extends Module\n{\n    public function install()\n    {\n        return parent::install() &&\n               $this->registerHook('actionOrderStatusUpdate') &&\n               $this->registerHook('actionProductSave');\n    }\n    \n    public function hookActionOrderStatusUpdate($params)\n    {\n        $order = $params['newOrderStatus'];\n        $webhookUrl = Configuration::get('WEBHOOK_ORDER_STATUS_URL');\n        \n        if ($webhookUrl) {\n            $this->sendWebhook($webhookUrl, [\n                'event' => 'order.status.changed',\n                'order_id' => $order->id,\n                'new_status' => $order->current_state,\n                'timestamp' => date('c')\n            ]);\n        }\n    }\n    \n    private function sendWebhook($url, $data)\n    {\n        $ch = curl_init($url);\n        curl_setopt($ch, CURLOPT_POST, true);\n        curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));\n        curl_setopt($ch, CURLOPT_HTTPHEADER, [\n            'Content-Type: application/json',\n            'X-Webhook-Source: PrestaShop'\n        ]);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n        \n        $response = curl_exec($ch);\n        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);\n        curl_close($ch);\n        \n        // Log resultado\n        PrestaShopLogger::addLog(\n            \"Webhook sent to $url - HTTP $httpCode\",\n            1,\n            null,\n            'WebhooksModule'\n        );\n    }\n}\n```\n\n## Mejores Prácticas para Módulos API\n\n### 1. Seguridad\n\n```php\n// Validación de API Key\nclass APIValidator\n{\n    public static function validateApiKey($apiKey)\n    {\n        $validKeys = Configuration::get('CUSTOM_API_KEYS');\n        $keys = json_decode($validKeys, true) ?: [];\n        \n        return in_array($apiKey, $keys);\n    }\n    \n    public static function rateLimitCheck($identifier)\n    {\n        $cacheKey = 'api_rate_limit_' . md5($identifier);\n        $requests = (int)Cache::getInstance()->get($cacheKey);\n        \n        if ($requests >= 100) { // 100 requests per hour\n            http_response_code(429);\n            die(json_encode(['error' => 'Rate limit exceeded']));\n        }\n        \n        Cache::getInstance()->set($cacheKey, $requests + 1, 3600);\n    }\n}\n```\n\n### 2. Logging y Monitoreo\n\n```php\nclass APILogger\n{\n    public static function logRequest($endpoint, $method, $params, $response)\n    {\n        $logData = [\n            'timestamp' => date('c'),\n            'endpoint' => $endpoint,\n            'method' => $method,\n            'params' => $params,\n            'response_code' => http_response_code(),\n            'ip' => $_SERVER['REMOTE_ADDR'],\n            'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? ''\n        ];\n        \n        PrestaShopLogger::addLog(\n            'API Request: ' . json_encode($logData),\n            1,\n            null,\n            'CustomAPI'\n        );\n    }\n}\n```\n\n### 3. Versionado de API\n\n```php\n// Soporte para múltiples versiones\nclass APIVersionManager\n{\n    const SUPPORTED_VERSIONS = ['v1', 'v2'];\n    const DEFAULT_VERSION = 'v1';\n    \n    public static function getVersion($request)\n    {\n        // Check header\n        if (isset($_SERVER['HTTP_API_VERSION'])) {\n            return $_SERVER['HTTP_API_VERSION'];\n        }\n        \n        // Check URL path\n        if (preg_match('/\\/api\\/(v\\d+)\\//i', $request, $matches)) {\n            return $matches[1];\n        }\n        \n        return self::DEFAULT_VERSION;\n    }\n    \n    public static function isVersionSupported($version)\n    {\n        return in_array($version, self::SUPPORTED_VERSIONS);\n    }\n}\n```\n\n## Recomendaciones de Selección\n\n### Para Proyectos Nuevos\n1. **Frontend Moderno**: Binshops REST API\n2. **Queries Complejas**: GraphQL Module\n3. **Marketplace**: WebKul APIs\n4. **Integración ERP**: Módulo personalizado\n\n### Para Proyectos Existentes\n1. **Migración gradual**: API Wrapper híbrido\n2. **Compatibilidad**: API Oficial + extensiones\n3. **Funcionalidades específicas**: Módulos complementarios\n\n### Consideraciones de Costo\n- **Presupuesto limitado**: API Oficial + módulos gratuitos\n- **Proyecto comercial**: Binshops o WebKul\n- **Desarrollo interno**: Módulo personalizado\n\n---\n\n**Nota**: La elección del módulo API debe basarse en los requisitos específicos del proyecto, presupuesto disponible y recursos de desarrollo.